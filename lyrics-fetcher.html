<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé§ Automatic Lyrics Fetcher</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            color: #fff;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(220, 53, 69, 0.5);
        }
        
        .instructions {
            background: rgba(40, 167, 69, 0.1);
            border: 2px solid #28a745;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }
        
        .instructions h2 {
            color: #28a745;
            margin-bottom: 15px;
        }
        
        .instructions ol {
            margin-left: 20px;
            line-height: 1.8;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 15px 30px;
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
            transition: all 0.3s ease;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(220, 53, 69, 0.5);
        }
        
        button:disabled {
            background: linear-gradient(135deg, #555 0%, #444 100%);
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        button.success {
            background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
        }
        
        #progress-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            display: none;
        }
        
        #progress-section.show {
            display: block;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #222;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc3545 0%, #ff7788 100%);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #dc3545;
        }
        
        .stat-label {
            font-size: 0.9em;
            color: #888;
            margin-top: 5px;
        }
        
        #results {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .result-item {
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #666;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .result-item.success {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.1);
        }
        
        .result-item.not-found {
            border-color: #ffc107;
            background: rgba(255, 193, 7, 0.1);
        }
        
        .result-item.error {
            border-color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
        }
        
        .result-title {
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .result-detail {
            font-size: 0.9em;
            color: #aaa;
        }
        
        #results::-webkit-scrollbar {
            width: 8px;
        }
        
        #results::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }
        
        #results::-webkit-scrollbar-thumb {
            background: #dc3545;
            border-radius: 4px;
        }
        
        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal-overlay.show {
            display: flex;
        }
        
        .modal {
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            border: 2px solid #dc3545;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 50px rgba(220, 53, 69, 0.5);
        }
        
        .modal h2 {
            color: #dc3545;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .modal-file-info {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #ffc107;
        }
        
        .modal-info-line {
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        
        .modal-info-line strong {
            color: #ffc107;
        }
        
        .modal-attempts-log {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 0.85em;
            max-height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
        }
        
        .modal-message {
            color: #aaa;
            margin-bottom: 20px;
            text-align: center;
            line-height: 1.5;
        }
        
        .modal-label {
            display: block;
            margin-bottom: 8px;
            color: #aaa;
            font-size: 0.9em;
        }
        
        .modal-input {
            width: 100%;
            padding: 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #555;
            border-radius: 8px;
            color: #fff;
            font-size: 16px;
            margin-bottom: 15px;
            transition: border-color 0.3s;
        }
        
        .modal-input:focus {
            outline: none;
            border-color: #dc3545;
        }
        
        .modal-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        
        .modal-buttons button {
            flex: 1;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #555 0%, #444 100%);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé§ Automatic Lyrics Fetcher</h1>
        
        <div class="instructions">
            <h2>üìñ How to Use</h2>
            <ol>
                <li>Click <strong>"Select Music Folder"</strong> and choose your music folder</li>
                <li>The tool will scan all audio files and read their metadata</li>
                <li>Click <strong>"Fetch Lyrics for All Songs"</strong> to automatically download synced lyrics</li>
                <li>The tool tries <strong>dozens of variations</strong> across <strong>multiple APIs</strong> before asking for help</li>
                <li>VTT files will be saved with matching filenames in a ZIP file</li>
                <li>Extract the ZIP and place the VTT files in your music folder</li>
                <li>Reload your music player - lyrics will appear automatically!</li>
            </ol>
        </div>
        
        <div class="button-group">
            <button id="select-folder-btn">üìÅ Select Music Folder</button>
            <button id="fetch-lyrics-btn" disabled>üé§ Fetch Lyrics for All Songs</button>
            <button id="download-zip-btn" disabled style="display: none;">üíæ Download VTT Files (ZIP)</button>
        </div>
        
        <div id="progress-section">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill">0%</div>
            </div>
            <div id="status-text" style="text-align: center; margin-bottom: 15px;">Ready...</div>
            
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-number" id="stat-total">0</div>
                    <div class="stat-label">Total Songs</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="stat-found" style="color: #28a745;">0</div>
                    <div class="stat-label">Lyrics Found</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="stat-not-found" style="color: #ffc107;">0</div>
                    <div class="stat-label">Not Found</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="stat-errors" style="color: #dc3545;">0</div>
                    <div class="stat-label">Failed</div>
                </div>
            </div>
        </div>
        
        <div id="results"></div>
    </div>
    
    <!-- Manual Input Modal -->
    <div class="modal-overlay" id="manual-input-modal">
        <div class="modal">
            <h2>‚ö†Ô∏è Lyrics Not Found</h2>
            <div class="modal-file-info">
                <div class="modal-info-line"><strong>File:</strong> <span id="modal-filename"></span></div>
                <div class="modal-info-line"><strong>All attempts:</strong></div>
                <div class="modal-attempts-log" id="modal-attempts"></div>
            </div>
            <p class="modal-message">
                Could not find lyrics after exhaustive search. Please enter correct track information:
            </p>
            
            <label class="modal-label">Track Name</label>
            <input type="text" class="modal-input" id="manual-track-name" placeholder="Enter song title">
            
            <label class="modal-label">Artist Name</label>
            <input type="text" class="modal-input" id="manual-artist-name" placeholder="Enter artist name">
            
            <div class="modal-buttons">
                <button class="btn-secondary" id="modal-skip-btn">Skip & Mark Failed</button>
                <button id="modal-submit-btn">Retry Search</button>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>
    function createWorker() {
        const workerCode = document.getElementById('worker-code').textContent;
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        return new Worker(URL.createObjectURL(blob));
    }
</script>
    <script>
    // LyricsSearchEngine for manual retries
    class LyricsSearchEngine {
        constructor() {
            this.attemptLog = [];
            this.rateLimitDelay = 200;
        }

        async enhancedSmartSearch(artist, title) {
            this.attemptLog = [];
            
            const titleVariations = this.getTitleVariations(title);
            const artistVariations = this.getArtistVariations(artist);
            
            let result = await this.tryLRCLIB(artist, title, 'LRCLIB: Exact match');
            if (result) return result;
            
            const cleanedTitle = this.cleanString(title);
            const cleanedArtist = this.cleanString(artist);
            
            if (cleanedTitle !== title || cleanedArtist !== artist) {
                result = await this.tryLRCLIB(cleanedArtist, cleanedTitle, 'LRCLIB: Cleaned');
                if (result) return result;
            }
            
            for (const titleVar of titleVariations.slice(0, 5)) {
                result = await this.tryLRCLIB(cleanedArtist, titleVar, `LRCLIB: Title var "${titleVar.substring(0, 30)}..."`);
                if (result) return result;
            }
            
            for (const artistVar of artistVariations.slice(0, 5)) {
                result = await this.tryLRCLIB(artistVar, cleanedTitle, `LRCLIB: Artist var "${artistVar}"`);
                if (result) return result;
            }
            
            result = await this.tryLRCLIB(cleanedTitle, cleanedArtist, 'LRCLIB: Swapped artist/title');
            if (result) return result;
            
            result = await this.tryLRCLIBSearch(cleanedArtist, cleanedTitle, 'LRCLIB: Fuzzy search');
            if (result) return result;
            
            result = await this.tryLyricsOVH(cleanedArtist, cleanedTitle, 'Lyrics.ovh: Search');
            if (result) return result;
            
            return null;
        }

        getTitleVariations(title) {
            const variations = [];
            variations.push(title.replace(/\s*-?\s*topic\s*$/gi, '').trim());
            variations.push(title.replace(/\s*-?\s*(remastered|remaster|deluxe|edition|version|single|album|mix|radio edit)\s*(\(\d+\))?/gi, '').trim());
            variations.push(title.replace(/\s*\(feat\..*?\)/gi, '').trim());
            variations.push(title.replace(/\s*ft\..*$/gi, '').trim());
            variations.push(title.replace(/\s*featuring.*$/gi, '').trim());
            variations.push(title.replace(/'/g, ''));
            variations.push(title.replace(/'/g, ''));
            if (title.toLowerCase().startsWith('the ')) {
                variations.push(title.substring(4));
            }
            variations.push(title.replace(/[^\w\s\-&]/g, ' ').replace(/\s+/g, ' ').trim());
            variations.push(title.replace(/\([^)]*\)/g, '').replace(/\[[^\]]*\]/g, '').trim());
            return [...new Set(variations.filter(v => v && v !== title && v.length > 1))];
        }

        getArtistVariations(artist) {
            const variations = [];
            variations.push(artist.replace(/\s*-?\s*topic\s*$/gi, '').trim());
            if (!artist.toLowerCase().includes('cast')) {
                variations.push(`${artist} Cast`);
            }
            if (artist.toLowerCase().includes('cast')) {
                variations.push(artist.replace(/\s*cast\s*/gi, '').trim());
            }
            if (artist.includes(',')) {
                variations.push(artist.split(',')[0].trim());
            }
            if (artist.toLowerCase().startsWith('the ')) {
                variations.push(artist.substring(4));
            }
            if (artist.includes('&') || artist.toLowerCase().includes(' and ')) {
                variations.push(artist.split(/\s*&\s*|\s+and\s+/i)[0].trim());
            }
            return [...new Set(variations.filter(v => v && v !== artist && v.length > 0))];
        }

        cleanString(str) {
            return str
                .replace(/\s*-?\s*topic\s*$/gi, '')
                .replace(/\([^)]*\)/g, '')
                .replace(/\[[^\]]*\]/g, '')
                .replace(/\s*feat\.?\s*.*/i, '')
                .replace(/\s*ft\.?\s*.*/i, '')
                .replace(/\s*featuring\s*.*/i, '')
                .replace(/\s*with\s*.*/i, '')
                .replace(/\s+/g, ' ')
                .trim();
        }

        async tryLRCLIB(artist, title, attemptDesc) {
            await this.rateLimit();
            
            try {
                const params = new URLSearchParams({
                    artist_name: artist,
                    track_name: title
                });
                
                const response = await fetch(`https://lrclib.net/api/get?${params}`);
                
                if (response.ok) {
                    const data = await response.json();
                    
                    if (data.syncedLyrics) {
                        this.attemptLog.push(`‚úì ${attemptDesc}`);
                        return this.parseLRC(data.syncedLyrics);
                    } else if (data.plainLyrics) {
                        this.attemptLog.push(`‚úì ${attemptDesc} (unsynced)`);
                        return this.createFakeSyncedLyrics(data.plainLyrics);
                    }
                }
                
                this.attemptLog.push(`‚úó ${attemptDesc}`);
            } catch (err) {
                this.attemptLog.push(`‚úó ${attemptDesc} (error: ${err.message})`);
            }
            
            return null;
        }

        async tryLRCLIBSearch(artist, title, attemptDesc) {
            await this.rateLimit();
            
            try {
                const params = new URLSearchParams({
                    track_name: title,
                    artist_name: artist
                });
                
                const response = await fetch(`https://lrclib.net/api/search?${params}`);
                
                if (response.ok) {
                    const results = await response.json();
                    
                    if (results && results.length > 0) {
                        const first = results[0];
                        
                        if (first.syncedLyrics) {
                            this.attemptLog.push(`‚úì ${attemptDesc}: "${first.trackName}" by ${first.artistName}`);
                            return this.parseLRC(first.syncedLyrics);
                        } else if (first.plainLyrics) {
                            this.attemptLog.push(`‚úì ${attemptDesc} (unsynced): "${first.trackName}" by ${first.artistName}`);
                            return this.createFakeSyncedLyrics(first.plainLyrics);
                        }
                    }
                }
                
                this.attemptLog.push(`‚úó ${attemptDesc}`);
            } catch (err) {
                this.attemptLog.push(`‚úó ${attemptDesc} (error: ${err.message})`);
            }
            
            return null;
        }

        async tryLyricsOVH(artist, title, attemptDesc) {
            await this.rateLimit();
            
            try {
                const response = await fetch(`https://api.lyrics.ovh/v1/${encodeURIComponent(artist)}/${encodeURIComponent(title)}`);
                
                if (response.ok) {
                    const data = await response.json();
                    
                    if (data.lyrics) {
                        this.attemptLog.push(`‚úì ${attemptDesc} (unsynced)`);
                        return this.createFakeSyncedLyrics(data.lyrics);
                    }
                }
                
                this.attemptLog.push(`‚úó ${attemptDesc}`);
            } catch (err) {
                this.attemptLog.push(`‚úó ${attemptDesc} (error: ${err.message})`);
            }
            
            return null;
        }

        parseLRC(lrcContent) {
            const lines = lrcContent.split('\n');
            const lyrics = [];
            
            for (const line of lines) {
                const match = line.match(/\[(\d+):(\d+)\.(\d+)\](.*)/);
                if (match) {
                    const minutes = parseInt(match[1]);
                    const seconds = parseInt(match[2]);
                    const centiseconds = parseInt(match[3]);
                    const text = match[4].trim();
                    
                    const time = minutes * 60 + seconds + centiseconds / 100;
                    lyrics.push({ time, text });
                }
            }
            
            return lyrics.length > 0 ? lyrics : null;
        }

        createFakeSyncedLyrics(plainLyrics) {
            const lines = plainLyrics.split('\n');
            return lines.map((text, i) => ({
                time: i * 3,
                text: text.trim()
            })).filter(l => l.text);
        }

        async rateLimit() {
            await new Promise(resolve => setTimeout(resolve, this.rateLimitDelay));
        }

        getAttemptSummary() {
            return this.attemptLog.join('\n');
        }
    }
</script>
<script id="worker-code" type="text/plain">
    
    // ========== MetadataParser Class ==========
class MetadataParser {
    constructor(debugLog) {
        this.debugLog = debugLog || (() => {});
    }

    async extractMetadata(file) {
        const extension = file.name.split('.').pop().toLowerCase();
        
        try {
            let metadata;
            
            switch(extension) {
                case 'mp3':
                    metadata = await this.parseMP3(file);
                    break;
                case 'm4a':
                case 'mp4':
                case 'aac':
                    metadata = await this.parseM4A(file);
                    break;
                case 'flac':
                    metadata = await this.parseFLAC(file);
                    break;
                case 'ogg':
                    metadata = await this.parseOGG(file);
                    break;
                case 'wav':
                    metadata = await this.parseWAV(file);
                    break;
                default:
                    throw new Error(`Unsupported format: ${extension}`);
            }
            
            return metadata;
            
        } catch (err) {
            throw new Error(`Metadata extraction failed: ${err.message}`);
        }
    }

    async parseMP3(file) {
        const buffer = await this.readFileChunk(file, 0, 500000);
        const view = new DataView(buffer);
        
        if (String.fromCharCode(view.getUint8(0), view.getUint8(1), view.getUint8(2)) !== 'ID3') {
            throw new Error('No ID3v2 tag found');
        }
        
        const version = view.getUint8(3);
        const tagSize = this.synchsafe32(view, 6);
        
        let metadata = { title: null, artist: null, album: null };
        let pos = 10;

        while (pos < tagSize + 10) {
            if (pos + 10 > buffer.byteLength) break;
            
            const frameId = String.fromCharCode(
                view.getUint8(pos), view.getUint8(pos+1), 
                view.getUint8(pos+2), view.getUint8(pos+3)
            );
            
            const frameSize = version === 4 
                ? this.synchsafe32(view, pos + 4)
                : view.getUint32(pos + 4);
            
            if (frameSize === 0 || frameSize > tagSize) break;
            
            const dataStart = pos + 10;
            const encoding = view.getUint8(dataStart);

            if (frameId === 'TIT2') metadata.title = this.decodeText(view, dataStart + 1, frameSize - 1, encoding);
            if (frameId === 'TPE1') metadata.artist = this.decodeText(view, dataStart + 1, frameSize - 1, encoding);
            if (frameId === 'TALB') metadata.album = this.decodeText(view, dataStart + 1, frameSize - 1, encoding);
            
            pos += 10 + frameSize;
        }
        
        return this.normalizeMetadata(metadata, file);
    }

    async parseM4A(file) {
        const buffer = await this.readFileChunk(file, 0, 200000);
        const view = new DataView(buffer);
        
        let metadata = { title: null, artist: null, album: null };
        let pos = 0;

        while (pos < buffer.byteLength - 8) {
            const atomSize = view.getUint32(pos);
            const atomType = String.fromCharCode(
                view.getUint8(pos+4), view.getUint8(pos+5), 
                view.getUint8(pos+6), view.getUint8(pos+7)
            );
            
            if (atomType === 'moov') {
                const ilst = this.findAtom(view, pos + 8, atomSize - 8, ['udta', 'meta', 'ilst']);
                if (ilst) {
                    metadata = this.parseILST(view, ilst.pos, ilst.size);
                }
                break;
            }
            
            pos += atomSize;
        }
        
        return this.normalizeMetadata(metadata, file);
    }

    parseILST(view, start, size) {
        const metadata = { title: null, artist: null, album: null };
        let pos = start;
        const end = start + size;

        while (pos < end - 8) {
            const atomSize = view.getUint32(pos);
            if (atomSize === 0 || atomSize > (end - pos)) break;
            
            const atomType = String.fromCharCode(
                view.getUint8(pos+4), view.getUint8(pos+5), 
                view.getUint8(pos+6), view.getUint8(pos+7)
            );
            
            const dataPos = pos + 8;
            const dataSize = view.getUint32(dataPos);
            const dataType = String.fromCharCode(
                view.getUint8(dataPos+4), view.getUint8(dataPos+5), 
                view.getUint8(dataPos+6), view.getUint8(dataPos+7)
            );
            
            if (dataType === 'data') {
                const dataFlags = view.getUint32(dataPos + 8);
                const textStart = dataPos + 16;
                const textLen = dataSize - 16;
                
                if (dataFlags === 1) {
                    const text = this.decodeText(view, textStart, textLen, 1);
                    
                    if (atomType === '¬©nam') metadata.title = text;
                    if (atomType === '¬©ART') metadata.artist = text;
                    if (atomType === '¬©alb') metadata.album = text;
                }
            }
            
            pos += atomSize;
        }
        
        return metadata;
    }

    async parseFLAC(file) {
        const buffer = await this.readFileChunk(file, 0, 200000);
        const view = new DataView(buffer);
        
        if (String.fromCharCode(view.getUint8(0), view.getUint8(1), view.getUint8(2), view.getUint8(3)) !== 'fLaC') {
            throw new Error('Not a valid FLAC file');
        }
        
        let metadata = { title: null, artist: null, album: null };
        let pos = 4;

        while (pos < buffer.byteLength - 4) {
            const header = view.getUint8(pos);
            const isLast = (header & 0x80) !== 0;
            const blockType = header & 0x7F;
            const blockSize = (view.getUint8(pos+1) << 16) | (view.getUint8(pos+2) << 8) | view.getUint8(pos+3);
            
            pos += 4;
            
            if (blockType === 4) {
                metadata = this.parseVorbisComment(view, pos, blockSize);
            }
            
            pos += blockSize;
            if (isLast) break;
        }
        
        return this.normalizeMetadata(metadata, file);
    }

    parseVorbisComment(view, start, size) {
        const metadata = { title: null, artist: null, album: null };
        let pos = start;
        
        const vendorLen = view.getUint32(pos, true);
        pos += 4 + vendorLen;
        
        const commentCount = view.getUint32(pos, true);
        pos += 4;
        
        for (let i = 0; i < commentCount; i++) {
            const commentLen = view.getUint32(pos, true);
            pos += 4;
            
            const comment = this.decodeText(view, pos, commentLen, 1);
            pos += commentLen;
            
            const [key, value] = comment.split('=', 2);
            const keyUpper = key.toUpperCase();
            
            if (keyUpper === 'TITLE') metadata.title = value;
            if (keyUpper === 'ARTIST') metadata.artist = value;
            if (keyUpper === 'ALBUM') metadata.album = value;
        }
        
        return metadata;
    }

    async parseOGG(file) {
        const buffer = await this.readFileChunk(file, 0, 100000);
        const view = new DataView(buffer);
        
        if (String.fromCharCode(view.getUint8(0), view.getUint8(1), view.getUint8(2), view.getUint8(3)) !== 'OggS') {
            throw new Error('Not a valid OGG file');
        }
        
        let metadata = { title: null, artist: null, album: null };
        let pos = 0;

        while (pos < buffer.byteLength - 27) {
            if (String.fromCharCode(view.getUint8(pos), view.getUint8(pos+1), view.getUint8(pos+2), view.getUint8(pos+3)) !== 'OggS') {
                pos++;
                continue;
            }
            
            const segmentCount = view.getUint8(pos + 26);
            pos += 27;
            
            let pageSize = 0;
            for (let i = 0; i < segmentCount; i++) {
                pageSize += view.getUint8(pos + i);
            }
            pos += segmentCount;
            
            const packetType = view.getUint8(pos);
            if (packetType === 3) {
                const vorbisStr = String.fromCharCode(
                    view.getUint8(pos+1), view.getUint8(pos+2), 
                    view.getUint8(pos+3), view.getUint8(pos+4), 
                    view.getUint8(pos+5), view.getUint8(pos+6)
                );
                
                if (vorbisStr === 'vorbis') {
                    metadata = this.parseVorbisComment(view, pos + 7, pageSize - 7);
                    break;
                }
            }
            
            pos += pageSize;
        }
        
        return this.normalizeMetadata(metadata, file);
    }

    async parseWAV(file) {
        const buffer = await this.readFileChunk(file, 0, 100000);
        const view = new DataView(buffer);
        
        if (String.fromCharCode(view.getUint8(0), view.getUint8(1), view.getUint8(2), view.getUint8(3)) !== 'RIFF') {
            throw new Error('Not a valid WAV file');
        }
        
        let metadata = { title: null, artist: null, album: null };
        let pos = 12;

        while (pos < buffer.byteLength - 8) {
            const chunkId = String.fromCharCode(
                view.getUint8(pos), view.getUint8(pos+1), 
                view.getUint8(pos+2), view.getUint8(pos+3)
            );
            const chunkSize = view.getUint32(pos + 4, true);
            
            if (chunkId === 'LIST') {
                const listType = String.fromCharCode(
                    view.getUint8(pos+8), view.getUint8(pos+9), 
                    view.getUint8(pos+10), view.getUint8(pos+11)
                );
                
                if (listType === 'INFO') {
                    metadata = this.parseWAVInfo(view, pos + 12, chunkSize - 4);
                }
            }
            
            pos += 8 + chunkSize;
            if (chunkSize % 2 !== 0) pos++;
        }
        
        return this.normalizeMetadata(metadata, file);
    }

    parseWAVInfo(view, start, size) {
        const metadata = { title: null, artist: null, album: null };
        let pos = start;
        const end = start + size;

        while (pos < end - 8) {
            const fieldId = String.fromCharCode(
                view.getUint8(pos), view.getUint8(pos+1), 
                view.getUint8(pos+2), view.getUint8(pos+3)
            );
            const fieldSize = view.getUint32(pos + 4, true);
            
            const text = this.decodeText(view, pos + 8, fieldSize, 0);
            
            if (fieldId === 'INAM') metadata.title = text;
            if (fieldId === 'IART') metadata.artist = text;
            if (fieldId === 'IPRD') metadata.album = text;
            
            pos += 8 + fieldSize;
            if (fieldSize % 2 !== 0) pos++;
        }
        
        return metadata;
    }

    async readFileChunk(file, start, length) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = () => reject(new Error('File read failed'));
            reader.readAsArrayBuffer(file.slice(start, start + length));
        });
    }

    synchsafe32(view, offset) {
        return (view.getUint8(offset) << 21) | 
               (view.getUint8(offset+1) << 14) | 
               (view.getUint8(offset+2) << 7) | 
               view.getUint8(offset+3);
    }

    decodeText(view, start, length, encoding) {
        const bytes = new Uint8Array(view.buffer, start, length);
        
        try {
            if (encoding === 0) {
                return String.fromCharCode(...bytes);
            } else if (encoding === 1 || encoding === undefined) {
                return new TextDecoder('utf-8').decode(bytes);
            } else if (encoding === 2) {
                return new TextDecoder('utf-16le').decode(bytes);
            } else if (encoding === 3) {
                return new TextDecoder('utf-16be').decode(bytes);
            }
        } catch (e) {
            return String.fromCharCode(...bytes.filter(b => b >= 32 && b <= 126));
        }
        
        return '';
    }

    findAtom(view, start, size, path) {
        let pos = start;
        const end = start + size;
        const targetAtom = path[0];
        
        while (pos < end - 8) {
            const atomSize = view.getUint32(pos);
            if (atomSize === 0 || atomSize > (end - pos)) break;
            
            const atomType = String.fromCharCode(
                view.getUint8(pos+4), view.getUint8(pos+5), 
                view.getUint8(pos+6), view.getUint8(pos+7)
            );
            
            if (atomType === targetAtom) {
                if (path.length === 1) {
                    return { pos: pos + 8, size: atomSize - 8 };
                } else {
                    return this.findAtom(view, pos + 8, atomSize - 8, path.slice(1));
                }
            }
            
            pos += atomSize;
        }
        
        return null;
    }

    normalizeMetadata(metadata, file) {
        if (!metadata.title || !metadata.artist) {
            throw new Error('Missing title or artist');
        }
        
        return {
            title: metadata.title,
            artist: metadata.artist,
            album: metadata.album || 'Unknown Album'
        };
    }
}

// ========== LyricsSearchEngine Class ==========
class LyricsSearchEngine {
    constructor() {
        this.attemptLog = [];
        this.rateLimitDelay = 200;
    }

    async enhancedSmartSearch(artist, title) {
        this.attemptLog = [];
        
        const titleVariations = this.getTitleVariations(title);
        const artistVariations = this.getArtistVariations(artist);
        
        let result = await this.tryLRCLIB(artist, title, 'LRCLIB: Exact match');
        if (result) return result;
        
        const cleanedTitle = this.cleanString(title);
        const cleanedArtist = this.cleanString(artist);
        
        if (cleanedTitle !== title || cleanedArtist !== artist) {
            result = await this.tryLRCLIB(cleanedArtist, cleanedTitle, 'LRCLIB: Cleaned');
            if (result) return result;
        }
        
        for (const titleVar of titleVariations.slice(0, 5)) {
            result = await this.tryLRCLIB(cleanedArtist, titleVar, `LRCLIB: Title var "${titleVar.substring(0, 30)}..."`);
            if (result) return result;
        }
        
        for (const artistVar of artistVariations.slice(0, 5)) {
            result = await this.tryLRCLIB(artistVar, cleanedTitle, `LRCLIB: Artist var "${artistVar}"`);
            if (result) return result;
        }
        
        result = await this.tryLRCLIB(cleanedTitle, cleanedArtist, 'LRCLIB: Swapped artist/title');
        if (result) return result;
        
        result = await this.tryLRCLIBSearch(cleanedArtist, cleanedTitle, 'LRCLIB: Fuzzy search');
        if (result) return result;
        
        result = await this.tryLyricsOVH(cleanedArtist, cleanedTitle, 'Lyrics.ovh: Search');
        if (result) return result;
        
        return null;
    }

    getTitleVariations(title) {
        const variations = [];
        variations.push(title.replace(/\s*-?\s*topic\s*$/gi, '').trim());
        variations.push(title.replace(/\s*-?\s*(remastered|remaster|deluxe|edition|version|single|album|mix|radio edit)\s*(\(\d+\))?/gi, '').trim());
        variations.push(title.replace(/\s*\(feat\..*?\)/gi, '').trim());
        variations.push(title.replace(/\s*ft\..*$/gi, '').trim());
        variations.push(title.replace(/\s*featuring.*$/gi, '').trim());
        variations.push(title.replace(/'/g, ''));
        variations.push(title.replace(/'/g, ''));
        if (title.toLowerCase().startsWith('the ')) {
            variations.push(title.substring(4));
        }
        variations.push(title.replace(/[^\w\s\-&]/g, ' ').replace(/\s+/g, ' ').trim());
        variations.push(title.replace(/\([^)]*\)/g, '').replace(/\[[^\]]*\]/g, '').trim());
        return [...new Set(variations.filter(v => v && v !== title && v.length > 1))];
    }

    getArtistVariations(artist) {
        const variations = [];
        variations.push(artist.replace(/\s*-?\s*topic\s*$/gi, '').trim());
        if (!artist.toLowerCase().includes('cast')) {
            variations.push(`${artist} Cast`);
        }
        if (artist.toLowerCase().includes('cast')) {
            variations.push(artist.replace(/\s*cast\s*/gi, '').trim());
        }
        if (artist.includes(',')) {
            variations.push(artist.split(',')[0].trim());
        }
        if (artist.toLowerCase().startsWith('the ')) {
            variations.push(artist.substring(4));
        }
        if (artist.includes('&') || artist.toLowerCase().includes(' and ')) {
            variations.push(artist.split(/\s*&\s*|\s+and\s+/i)[0].trim());
        }
        return [...new Set(variations.filter(v => v && v !== artist && v.length > 0))];
    }

    cleanString(str) {
        return str
            .replace(/\s*-?\s*topic\s*$/gi, '')
            .replace(/\([^)]*\)/g, '')
            .replace(/\[[^\]]*\]/g, '')
            .replace(/\s*feat\.?\s*.*/i, '')
            .replace(/\s*ft\.?\s*.*/i, '')
            .replace(/\s*featuring\s*.*/i, '')
            .replace(/\s*with\s*.*/i, '')
            .replace(/\s+/g, ' ')
            .trim();
    }

    async tryLRCLIB(artist, title, attemptDesc) {
        await this.rateLimit();
        
        try {
            const params = new URLSearchParams({
                artist_name: artist,
                track_name: title
            });
            
            const response = await fetch(`https://lrclib.net/api/get?${params}`);
            
            if (response.ok) {
                const data = await response.json();
                
                if (data.syncedLyrics) {
                    this.attemptLog.push(`‚úì ${attemptDesc}`);
                    return this.parseLRC(data.syncedLyrics);
                } else if (data.plainLyrics) {
                    this.attemptLog.push(`‚úì ${attemptDesc} (unsynced)`);
                    return this.createFakeSyncedLyrics(data.plainLyrics);
                }
            }
            
            this.attemptLog.push(`‚úó ${attemptDesc}`);
        } catch (err) {
            this.attemptLog.push(`‚úó ${attemptDesc} (error: ${err.message})`);
        }
        
        return null;
    }

    async tryLRCLIBSearch(artist, title, attemptDesc) {
        await this.rateLimit();
        
        try {
            const params = new URLSearchParams({
                track_name: title,
                artist_name: artist
            });
            
            const response = await fetch(`https://lrclib.net/api/search?${params}`);
            
            if (response.ok) {
                const results = await response.json();
                
                if (results && results.length > 0) {
                    const first = results[0];
                    
                    if (first.syncedLyrics) {
                        this.attemptLog.push(`‚úì ${attemptDesc}: "${first.trackName}" by ${first.artistName}`);
                        return this.parseLRC(first.syncedLyrics);
                    } else if (first.plainLyrics) {
                        this.attemptLog.push(`‚úì ${attemptDesc} (unsynced): "${first.trackName}" by ${first.artistName}`);
                        return this.createFakeSyncedLyrics(first.plainLyrics);
                    }
                }
            }
            
            this.attemptLog.push(`‚úó ${attemptDesc}`);
        } catch (err) {
            this.attemptLog.push(`‚úó ${attemptDesc} (error: ${err.message})`);
        }
        
        return null;
    }

    async tryLyricsOVH(artist, title, attemptDesc) {
        await this.rateLimit();
        
        try {
            const response = await fetch(`https://api.lyrics.ovh/v1/${encodeURIComponent(artist)}/${encodeURIComponent(title)}`);
            
            if (response.ok) {
                const data = await response.json();
                
                if (data.lyrics) {
                    this.attemptLog.push(`‚úì ${attemptDesc} (unsynced)`);
                    return this.createFakeSyncedLyrics(data.lyrics);
                }
            }
            
            this.attemptLog.push(`‚úó ${attemptDesc}`);
        } catch (err) {
            this.attemptLog.push(`‚úó ${attemptDesc} (error: ${err.message})`);
        }
        
        return null;
    }

    parseLRC(lrcContent) {
        const lines = lrcContent.split('\n');
        const lyrics = [];
        
        for (const line of lines) {
            const match = line.match(/\[(\d+):(\d+)\.(\d+)\](.*)/);
            if (match) {
                const minutes = parseInt(match[1]);
                const seconds = parseInt(match[2]);
                const centiseconds = parseInt(match[3]);
                const text = match[4].trim();
                
                const time = minutes * 60 + seconds + centiseconds / 100;
                lyrics.push({ time, text });
            }
        }
        
        return lyrics.length > 0 ? lyrics : null;
    }

    createFakeSyncedLyrics(plainLyrics) {
        const lines = plainLyrics.split('\n');
        return lines.map((text, i) => ({
            time: i * 3,
            text: text.trim()
        })).filter(l => l.text);
    }

    async rateLimit() {
        await new Promise(resolve => setTimeout(resolve, this.rateLimitDelay));
    }

    getAttemptSummary() {
        return this.attemptLog.join('\n');
    }
}

// ========== Worker Message Handler ==========
self.onmessage = async function(e) {
    const { id, file, fileData } = e.data;
    
    try {
        // Recreate File object from data
        const fileObj = new File([fileData], file.name, { type: file.type });
        
        // Extract metadata
        const parser = new MetadataParser();
        let metadata;
        
        try {
            metadata = await parser.extractMetadata(fileObj);
        } catch (err) {
            const nameWithoutExt = file.name.replace(/\.[^/.]+$/, '');
            metadata = {
                title: nameWithoutExt,
                artist: 'Unknown Artist'
            };
        }
        
        // Search for lyrics
        const searchEngine = new LyricsSearchEngine();
        const lyrics = await searchEngine.enhancedSmartSearch(metadata.artist, metadata.title);
        
        // Send result back
        self.postMessage({
            id,
            success: true,
            file: file,
            metadata: metadata,
            lyrics: lyrics,
            attemptLog: searchEngine.getAttemptSummary()
        });
        
    } catch (err) {
        self.postMessage({
            id,
            success: false,
            file: file,
            error: err.message
        });
    }
};

    </script>
<script>

        // ========== Main Application ==========
        let musicFiles = [];
        let vttFiles = {};
        let stats = { total: 0, found: 0, notFound: 0, errors: 0 };
        let currentProcessingFile = null;
        let currentAttemptLog = '';
        let resolveManualInput = null;
        
        // Worker pool
        const MAX_WORKERS = 3;
        let workers = [];
        let activeWorkers = 0;
        
        const selectFolderBtn = document.getElementById('select-folder-btn');
        const fetchLyricsBtn = document.getElementById('fetch-lyrics-btn');
        const downloadZipBtn = document.getElementById('download-zip-btn');
        const progressSection = document.getElementById('progress-section');
        const progressFill = document.getElementById('progress-fill');
        const statusText = document.getElementById('status-text');
        const resultsDiv = document.getElementById('results');
        
        const modalOverlay = document.getElementById('manual-input-modal');
        const modalFilename = document.getElementById('modal-filename');
        const modalAttempts = document.getElementById('modal-attempts');
        const modalTrackName = document.getElementById('manual-track-name');
        const modalArtistName = document.getElementById('manual-artist-name');
        const modalSubmitBtn = document.getElementById('modal-submit-btn');
        const modalSkipBtn = document.getElementById('modal-skip-btn');
        
        // Select music folder
        selectFolderBtn.onclick = async () => {
            try {
                const dirHandle = await window.showDirectoryPicker({ mode: 'read' });
                
                musicFiles = [];
                statusText.textContent = 'Scanning folder...';
                progressSection.classList.add('show');
                
                for await (const entry of dirHandle.values()) {
                    if (entry.kind === 'file') {
                        const file = await entry.getFile();
                        if (file.name.match(/\.(mp3|m4a|flac|ogg|wav|aac)$/i)) {
                            musicFiles.push(file);
                        }
                    }
                }
                
                stats.total = musicFiles.length;
                updateStats();
                
                addResult(`Found ${musicFiles.length} audio files`, 'success');
                statusText.textContent = `Ready to fetch lyrics for ${musicFiles.length} songs`;
                fetchLyricsBtn.disabled = false;
                selectFolderBtn.textContent = `‚úÖ ${musicFiles.length} Songs Loaded`;
                selectFolderBtn.classList.add('success');
                
            } catch (err) {
                addResult(`Error: ${err.message}`, 'error');
            }
        };
        
        // Fetch lyrics for all songs with Web Workers
        fetchLyricsBtn.onclick = async () => {
            fetchLyricsBtn.disabled = true;
            selectFolderBtn.disabled = true;
            resultsDiv.innerHTML = '';
            stats = { total: musicFiles.length, found: 0, notFound: 0, errors: 0 };
            vttFiles = {};
            
            // Initialize workers
            workers = [];
            for (let i = 0; i < MAX_WORKERS; i++) {
                workers.push(createWorker());
            }
            
            // Process files with worker pool
            await processFilesWithWorkers(musicFiles);
            
            // Cleanup workers
            workers.forEach(worker => worker.terminate());
            workers = [];
            
            statusText.textContent = `‚úÖ Batch complete! Found ${stats.found}/${stats.total} songs. Processing ${failedSongs.length} failed songs...`;
            
            // Now process failed songs one by one
            if (failedSongs.length > 0) {
                await processFailedSongs();
            }
            
            statusText.textContent = `‚úÖ Complete! Found lyrics for ${stats.found}/${stats.total} songs (${stats.errors} failed)`;
            fetchLyricsBtn.textContent = '‚úÖ Fetch Complete';
            
            if (Object.keys(vttFiles).length > 0) {
                downloadZipBtn.style.display = 'inline-block';
                downloadZipBtn.disabled = false;
            }
        };
        
        // Process files using worker pool
        async function processFilesWithWorkers(files) {
            return new Promise(async (resolve) => {
                let completedCount = 0;
                let currentIndex = 0;
                
                // Handle worker results
                function handleWorkerMessage(e) {
                    const result = e.data;
                    completedCount++;
                    activeWorkers--;
                    
                    const progress = (completedCount / files.length) * 100;
                    progressFill.style.width = `${progress}%`;
                    progressFill.textContent = `${Math.round(progress)}%`;
                    
                    if (result.success) {
                        processWorkerResult(result);
                    } else {
                        stats.errors++;
                        addResult(`‚ùå ${result.file.name}: Error - ${result.error}`, 'error');
                    }
                    
                    updateStats();
                    
                    // Start next file if available
                    if (currentIndex < files.length) {
                        const nextFile = files[currentIndex++];
                        startWorkerTask(this, nextFile, currentIndex - 1);
                    }
                    
                    // Check if all done
                    if (completedCount === files.length) {
                        resolve();
                    }
                }
                
                // Start worker task
                async function startWorkerTask(worker, file, index) {
                    activeWorkers++;
                    statusText.textContent = `Processing: ${file.name} (${completedCount + 1}/${files.length}) - ${activeWorkers} active`;
                    addResult(`üîç ${file.name}: Searching...`, 'not-found');
                    
                    // Read file data to transfer to worker
                    const fileData = await file.arrayBuffer();
                    
                    worker.postMessage({
                        id: index,
                        file: { name: file.name, type: file.type },
                        fileData: fileData
                    }, [fileData]);
                }
                
                // Attach handlers to all workers
                workers.forEach(worker => {
                    worker.onmessage = handleWorkerMessage;
                });
                
                // Start initial batch of tasks
                const initialBatch = Math.min(MAX_WORKERS, files.length);
                for (let i = 0; i < initialBatch; i++) {
                    await startWorkerTask(workers[i % MAX_WORKERS], files[i], i);
                    currentIndex++;
                }
            });
        }
        
        // Store failed songs for later processing
        let failedSongs = [];
        
        // Process worker result
        async function processWorkerResult(result) {
            const { file, metadata, lyrics, attemptLog } = result;
            
            // If no lyrics found, store for later
            if (!lyrics) {
                failedSongs.push({ file, metadata, attemptLog });
                stats.notFound++;
                addResult(`‚ö†Ô∏è ${file.name}: No lyrics found - will prompt later`, 'not-found');
            } else {
                // Success - save VTT
                saveLyricsAsVTT(file.name, lyrics);
                stats.found++;
                addResult(`‚úÖ ${file.name}: Lyrics saved (${lyrics.length} lines)`, 'success');
            }
        }

    // Process failed songs one by one
        async function processFailedSongs() {
            for (let i = 0; i < failedSongs.length; i++) {
                const { file, metadata, attemptLog } = failedSongs[i];
                
                statusText.textContent = `Manual input needed (${i + 1}/${failedSongs.length}): ${file.name}`;
                
                const manualMetadata = await promptManualInput(file, metadata.title, metadata.artist, attemptLog);
                
                if (manualMetadata) {
                    // Retry with manual input
                    const searchEngine = new LyricsSearchEngine();
                    const manualLyrics = await searchEngine.enhancedSmartSearch(manualMetadata.artist, manualMetadata.title);
                    
                    if (manualLyrics) {
                        saveLyricsAsVTT(file.name, manualLyrics);
                        stats.found++;
                        stats.notFound--;
                        updateStats();
                        addResult(`‚úÖ ${file.name}: Found with manual input (${manualLyrics.length} lines)`, 'success');
                    } else {
                        stats.errors++;
                        stats.notFound--;
                        updateStats();
                        addResult(`‚ùå ${file.name}: Failed - No lyrics found even with manual input`, 'error');
                    }
                } else {
                    stats.errors++;
                    stats.notFound--;
                    updateStats();
                    addResult(`‚ùå ${file.name}: Failed - Skipped by user`, 'error');
                }
            }
            
            // Clear failed songs array
            failedSongs = [];
        }
        
        // Save lyrics as VTT file
        function saveLyricsAsVTT(filename, lyrics) {
            const vttContent = convertLRCtoVTT(lyrics);
            const vttFilename = filename.replace(/\.[^/.]+$/, '.vtt');
            vttFiles[vttFilename] = vttContent;
        }
        
        // Prompt for manual input
        function promptManualInput(file, title, artist, attempts) {
            return new Promise((resolve) => {
                currentProcessingFile = file;
                currentAttemptLog = attempts;
                
                modalFilename.textContent = file.name;
                modalAttempts.textContent = attempts;
                modalTrackName.value = title;
                modalArtistName.value = artist;
                modalOverlay.classList.add('show');
                modalTrackName.focus();
                modalTrackName.select();
                
                resolveManualInput = resolve;
            });
        }
        
        // Modal submit handler
        modalSubmitBtn.onclick = () => {
            const title = modalTrackName.value.trim();
            const artist = modalArtistName.value.trim();
            
            if (!title || !artist) {
                alert('Please enter both track name and artist name');
                return;
            }
            
            modalOverlay.classList.remove('show');
            
            if (resolveManualInput) {
                resolveManualInput({ title, artist });
                resolveManualInput = null;
            }
        };
        
        // Modal skip handler
        modalSkipBtn.onclick = () => {
            modalOverlay.classList.remove('show');
            
            if (resolveManualInput) {
                resolveManualInput(null);
                resolveManualInput = null;
            }
        };
        
        // Allow Enter key in inputs
        modalTrackName.onkeypress = modalArtistName.onkeypress = (e) => {
            if (e.key === 'Enter') {
                modalSubmitBtn.click();
            }
        };
        
        // Download ZIP
        downloadZipBtn.onclick = async () => {
            const zip = new JSZip();
            
            for (const [filename, content] of Object.entries(vttFiles)) {
                zip.file(filename, content);
            }
            
            const blob = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `lyrics_${Date.now()}.zip`;
            a.click();
            URL.revokeObjectURL(url);
            
            addResult(`üì¶ Downloaded ${Object.keys(vttFiles).length} VTT files as ZIP`, 'success');
        };
        
        // Convert LRC to VTT
        function convertLRCtoVTT(lyrics) {
            let vtt = 'WEBVTT\n\n';
            
            for (let i = 0; i < lyrics.length; i++) {
                const current = lyrics[i];
                const next = lyrics[i + 1];
                
                const startTime = formatVTTTime(current.time);
                const endTime = next ? formatVTTTime(next.time) : formatVTTTime(current.time + 5);
                
                vtt += `${startTime} --> ${endTime}\n`;
                vtt += `${current.text}\n\n`;
            }
            
            return vtt;
        }
        
        // Format VTT timestamp
        function formatVTTTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            const millis = Math.floor((seconds % 1) * 1000);
            
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}.${String(millis).padStart(3, '0')}`;
        }
        
        // Add result to log
        function addResult(message, type) {
            const item = document.createElement('div');
            item.className = `result-item ${type}`;
            item.innerHTML = `<div class="result-title">${message}</div>`;
            resultsDiv.appendChild(item);
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }
        
        // Update statistics
        function updateStats() {
            document.getElementById('stat-total').textContent = stats.total;
            document.getElementById('stat-found').textContent = stats.found;
            document.getElementById('stat-not-found').textContent = stats.notFound;
            document.getElementById('stat-errors').textContent = stats.errors;
        }
        
        // Sleep utility
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>